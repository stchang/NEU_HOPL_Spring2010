@inproceedings{Abadi1989Dynamic,
  author    = {Mart\'{\i}n Abadi and
               Luca Cardelli and
               Benjamin C. Pierce and
               Gordon D. Plotkin},
  title     = {Dynamic Typing in a Statically-Typed Language},
  booktitle = {POPL},
  year      = {1989},
  pages     = {213-227},
  ee        = {http://doi.acm.org/10.1145/75277.75296},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@article{Abadi1991Dynamic,
  author    = {Mart\'{\i}n Abadi and
               Luca Cardelli and
               Benjamin C. Pierce and
               Gordon D. Plotkin},
  title     = {Dynamic Typing in a Statically Typed Language},
  journal   = {ACM Trans. Program. Lang. Syst.},
  volume    = {13},
  number    = {2},
  year      = {1991},
  pages     = {237-268},
  ee        = {http://doi.acm.org/10.1145/103135.103138},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  abstract = {Statically typed programming languages allow earlier error checking, better enforcement of
disciplined programming styles, and the generation of more efficient object code than languages
where all type consistency checks are performed at run time. However, even in statically typed
languages, there is often the need to deal with data whose type cannot be determined at compile
time. To handle such situations safely, we propose to add a type Dynamic whose values are
pairs of a value v and a type tag T, where v has the type denoted by T. Instances of Dynamic
are built with an explicit tagging construct and inspected with a type safe typecase construct.
This paper explores the syntax, operational semantics, and denotational semantics of a simple
language that includes the type Dynamic. We give examples of how dynamically typed values
can be used in programming. Then we discuss an operational semantics for our language and
obtain a soundness theorem, We present two formulations of the denotational semantics of this
language and relate them to the operational semantics. Finally, we consider the implications of
polymorphism and some implementation issues.}
}

@article{Abadi1995DynamicPolymorphic,
  author    = {Mart\'{\i}n Abadi and
               Luca Cardelli and
               Benjamin C. Pierce and
               Didier R{\'e}my},
  title     = {Dynamic Typing in Polymorphic Languages},
  journal   = {J. Funct. Program.},
  volume    = {5},
  number    = {1},
  year      = {1995},
  pages     = {111-130},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  abstract = {There are situations in programming where some dynamic typing is needed, even in the presence of advanced static type systems. We investigate the interplay of dynamic types with other advanced type constructions, discussing their integration into languages with explicit polymorphism (in the style of system F), implicit polymorphism (in the style of ML), abstract data types, and subtyping.}
}

@inproceedings{Leroy1991Dynamics,
  author    = {Xavier Leroy and
               Michel Mauny},
  title     = {Dynamics in ML},
  booktitle = {FPCA},
  year      = {1991},
  pages     = {406-426},
  crossref  = {DBLP:conf/fpca/1991},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  abstract = {Objects with dynamic types allow the integration of operations that essentially require
run-time type-checking into statically-typed languages. This paper presents two extensions of
the ML language with dynamics, based on what has been done in the CAML implementation
of ML, and discusses their usefulness. The main novelty of this work is the combination of
dynamics with polymorphism.}
}

@inproceedings{Gray2005FineGrained,
  author    = {Kathryn E. Gray and
               Robert Bruce Findler and
               Matthew Flatt},
  title     = {Fine-grained interoperability through mirrors and contracts},
  booktitle = {OOPSLA},
  year      = {2005},
  pages     = {231-245},
  ee        = {http://doi.acm.org/10.1145/1094811.1094830},
  crossref  = {DBLP:conf/oopsla/2005},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  abstract = {As a value ?ows across the boundary between interoperat-
ing languages, it must be checked and converted to ?t the
types and representations of the target language. For simple
forms of data, the checks and coercions can be immediate;
for higher order data, such as functions and objects, some
must be delayed until the value is used in a particular way.
Typically, these coercions and checks are implemented by an
ad-hoc mixture of wrappers, re?ection, and dynamic predi-
cates. We observe that 1) the wrapper and re?ection oper-
ations ?t the pro?le of mirrors, 2) the checks correspond to
contracts, and 3) the timing and shape of mirror operations
coincide with the timing and shape of contract operations.
Based on these insights, we present a new model of interop-
erability that builds on the ideas of mirrors and contracts,
and we describe an interoperable implementation of Java
and Scheme that is guided by the model.}
}

@article{MacQueen1986Ideal,
  author    = {David B. MacQueen and
               Gordon D. Plotkin and
               Ravi Sethi},
  title     = {An Ideal Model for Recursive Polymorphic Types},
  journal   = {Information and Control},
  volume    = {71},
  number    = {1/2},
  year      = {1986},
  pages     = {95-130},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@inproceedings{Findler2002Contracts,
  author    = {Robert Bruce Findler and
               Matthias Felleisen},
  title     = {Contracts for higher-order functions},
  booktitle = {ICFP},
  year      = {2002},
  pages     = {48-59},
  ee        = {http://doi.acm.org/10.1145/581478.581484},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@inproceedings{Bracha2004Mirrors,
  author    = {Gilad Bracha and
               David Ungar},
  title     = {Mirrors: design principles for meta-level facilities of
               object-oriented programming languages},
  booktitle = {OOPSLA},
  year      = {2004},
  pages     = {331-344},
  ee        = {http://doi.acm.org/10.1145/1028976.1029004},
  crossref  = {DBLP:conf/oopsla/2004p},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}
