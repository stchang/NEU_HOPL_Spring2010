% dynamic.tex

\documentclass[12pt]{article}	% YOUR INPUT FILE MUST CONTAIN THESE
\usepackage{url}
\usepackage{graphicx}
\oddsidemargin  -0.4in
\evensidemargin 0.0in
\textwidth      7in
\headheight     -0.5in
\topmargin      0.0in
\textheight     9.0in
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{xspace}
\usepackage{mathpartir}
\usepackage{alltt}



\begin{document}							% TWO LINES PLUS THE \end COMMAND AT
															% THE END
\newcommand{\Dynamic}{\texttt{Dynamic}\xspace}
\newcommand{\typecase}{\texttt{typecase}\xspace}
\newcommand{\dynamic}{\texttt{dynamic}\xspace}
\newcommand{\wrong}{\texttt{wrong}\xspace}
\newcommand{\deno}[1]{ \ensuremath{[\![#1]\!]} }
\newcommand{\code}[1]{$\mathtt{#1}$}
\newcommand{\pair}[2]{ \ensuremath{\left\langle #1,#2 \right\rangle} }
\newcommand{\pairtt}[2]{ \ensuremath{\left\langle \mathtt{#1,#2} \right\rangle} }


\title{Type Dynamic - Presentation Notes}
\author{Stephen Chang}
\date{2/26/2010}
\maketitle

\subsection*{Motivation}
\begin{enumerate}
	\item Static typecheckers have many advantages but sometimes dynamic typechecking is unavoidable. Type \Dynamic is about embedding dynamic typechecking within statically typed languages.
	\item What static type to give to \code{eval:string\rightarrow\;??}
	\item What static type to give to \code{print:\;??\rightarrow\;string}
	      Need to know type at runtime to dispatch proper type-specific print fn
	\item What static type to give to \code{read:IO\rightarrow\;??}
	      Can be from disk, another process, another computer over the network/internet
	\item Multi-language programs (use Gray,Findler,Flatt?)
\end{enumerate}

\subsection*{Background/History}
\begin{enumerate}
	\item languages with disjoint union (finite): Algol-68, Pascal (tagged variant record)
	\item language infinite disjoint union: Simula-67's subclass structure (INSPECT statement allows program to determine subclass of a value at run time)
	\item languages with dynamic typing in static context: CLU (\code{any} type/force), Cedar/Mesa (REFANY/TYPECASE), Modula-2+, Modula-3 (from Cedar/Mesa) -- these languages wanted to support programming idioms from LISP
	\item formalization of language with \Dynamic: Schaffert and Scheifler (1978) gave formal description and denotational semantics for CLU but did not give a soundness theorem -- also required every value to carry type tag at run time
	\item ML had some proposals for adding \Dynamic but ultimately unpublished: Gordon (1980, personal communication), Mycroft (1983, draft)
	\item languages with mechanisms for handling persistent data: Amber, Modula-2+ (pickling)
\end{enumerate}

\subsection*{Abadi, et al. (1989/1991) - Dynamic Typing in a Statically Typed Language}
\begin{enumerate}
	\item Introduce new datatype \Dynamic whose values pairs of value \texttt{v} and type tag \texttt{T} (so \Dynamic values carry type information at runtime) -- like an infinite disjoint union (sum type) -- allow values of different types to be manipulated uniformly
	\item \code{(dynamic\;e:T)} construct creates \Dynamic values and \typecase construct eliminates
	\item \typecase example:
	\begin{verbatim}
	tostring: Dynamic -> String
	  \dv:Dynamic.
	    typecase dv of
	      (v:String) (string-append '"' v '"')
	      (n:Nat) (natToStr n)
	      (X,Y)(f:X -> Y) "<function>"
	      (X,Y)(p:X x Y)
	        (string-append "<" (tostring (dynamic (fst p):X) ","
	                           (tostring (dynamic (snd p):Y) ">")
	      (d:Dynamic) (string-append "dynamic" (tostring d)
	      else "unknown"
	    end
	\end{verbatim}
	nested \typecase example:
	\begin{verbatim}
	\df:Dynamic.\de:Dynamic.
	  typecase df of
	    (X,Y)(f:X -> Y)
	      typecase de of
	        (e:X) (dynamic (f e):Y)
	        else (dynamic "Error":String)
	      end
	    else (dynamic "Error":String)
	  end
	\end{verbatim}
	\item Contribution: formal description of language with \Dynamic values -- cbv simply-typed lambda calculus + \dynamic and \typecase
	\item typecheck and eval rules for \dynamic:\\
	\inferrule{\Gamma \vdash e:T}{\Gamma\vdash(\dynamic\;e:T):\Dynamic}
	\inferrule{\vdash e \Rightarrow v}{\vdash(\dynamic\;e:T)\Rightarrow(\dynamic\;v:T)}
	\item typecheck and eval rules for \typecase:\\
	\inferrule{\Gamma \vdash e:\Dynamic \\\\ 
	           \forall i,\forall\sigma\in Subst_{\vec{X_i}} \; \Gamma[x_i \leftarrow T_i\sigma]\vdash e_i\sigma:T \\\\
	           \Gamma\vdash e_{else}:T}
	          {\Gamma\vdash(\typecase\;e\;\texttt{of} \\\\
	                        \ldots(\vec{X_i})(x_i:T_i)\;e_i\ldots\\\\
	                        \texttt{else}\; e_{else}\\\\
	                        \texttt{end}):T}\\
	 \inferrule{\vdash\;e\Rightarrow(\dynamic\;w:T)\\\\
	            \forall j<k.match(T,T_j) \textrm{fails}\\\\
	            match(T,T_k) = \sigma\\\\
	            \vdash e_k\sigma[x_k\leftarrow w]\Rightarrow v}
	           {\vdash(\typecase\;e\;\texttt{of}\\\\
	            \ldots(\vec{X_i})(x_i:T_i)\;e_i\ldots\\\\
	            \texttt{else}\; e_{else}\\\\
	            \texttt{end})\Rightarrow v}
	 \inferrule{\vdash\;e\Rightarrow(\dynamic\;w:T)\\\\
	            \forall k.match(T,T_k) \textrm{fails}\\\\
	            \vdash e_{else}\Rightarrow v}
	           {\vdash(\typecase\;e\;\texttt{of}\\\\
	            \ldots(\vec{X_i})(x_i:T_i)\;e_i\ldots\\\\
	            \texttt{else}\; e_{else}\\\\
	            \texttt{end})\Rightarrow v}
	\item Theorem: $\forall e, v, T$, if $\vdash e \Rightarrow v$ and $\vdash e:T$, then $v:T$\\
	      Corollary: $\forall e, v, T$ if $\vdash e \Rightarrow v$ and $\vdash e:T$, then $v \neq$ \wrong (because \wrong is not well-typed)
	\item Authors give denotational semantics -- difficulty is assigning meaning to \Dynamic values -- use ideal model of types and Banach Fixed Point theorem from MacQueen, Plotkin, Sethi (1986)
	\item Typechecking is sound: If $e$ is well typed, then $\deno{e}_\rho \neq \wrong$ (for well-behaved $\rho$)\\
	                             proved via: $\forall\Gamma,e,\rho,T$ ($\rho$ consistent with $\Gamma$ on $e$), if $\Gamma\vdash e:T$ then $\deno{e}_\rho \in \deno{T}$\\
	      Evaluation is sound: If $\vdash e \Rightarrow v$, then $\deno{e} = \deno{v}$
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abadi, et al. (1995) Dynamic Typing in Polymorphic Languages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Abadi, et al. (1995) - Dynamic Typing in Polymorphic Languages}

%% Explicit Polymorphism
\subsubsection*{Explicit Polymorphism}
\begin{enumerate}
	\item Contribution: add explicit polymorphism to language with \Dynamic -- get type abstractions $(\Lambda)$
	\item example:
	\begin{alltt}
	squarePolyFun = 
	  \(\lambda\)df:Dynamic
	    typecase df of
	      (f:\(\forall\)Z.Z\(\rightarrow\)Int)
	        \(\Lambda\)W.\(\lambda\)x:W.f[W](x)*f[W](x)
	      else \(\Lambda\)W.\(\lambda\)x:W.0
	\end{alltt}
	\item need second-order pattern variables that can be type operators in \typecase, example:
	\begin{alltt}
	dynamicApply = 
	  \(\lambda\)df:Dynamic.\(\lambda\)da:Dynamic.
	    typecase fg of
	      \{F,G\} (f:\(\forall\)Z.F(Z)\(\rightarrow\)G(Z))
	        typecase da of
	          \{W\} (a:F(W))
	            dynamic( f[W](a):G(W) )
	\end{alltt}
	if \code{df = dynamic(\;\Lambda Z.\lambda x:Z\times Z.\pair{snd(x)}{fst(x)}:\ldots\;)} \\
	and \code{da = dynamic(\pair{3}{4}:\ldots)} \\
	then \code{F = \Lambda X.X \times X}, \code{G = \Lambda X.X \times X}, and \code{W = Int} \\
	but if \code{df = dynamic(\;\Lambda Z.\lambda x:Z\rightarrow Z.x:\ldots\;)} \\
	and \code{da = dynamic(\lambda x:Int.x:\ldots)} \\
	then \code{F = \Lambda X.X \rightarrow X}, \code{G = \Lambda X.X\rightarrow X}, and \code{W = Int} \\
	
	\item Formally, \Dynamic values added to System $F_\omega$ (simply-typed lambda calculus + type abstractions + type operators)
	\item Having higher order pattern variables in \typecase allows ambiguous matches - example: pattern \code{F(Int)} matches tag \code{Int} with either \code{F=\Lambda X.X} or \code{F=\Lambda X.Int}.
	\item So patterns must be restricted so that they match any tag uniquely (this property is called definiteness) - restrict language to only second-order polymorphism
	\item Authors go not give typing or evaluation rules for explicit polymorphism
\end{enumerate}

%% Implicit Polymorphism
\subsubsection*{Implicit Polymorphism}
\begin{enumerate}
	\item In a language with implicit polymorphism (like ML), some changes need to be made to matching algorithm
	\item \dynamic construct only takes one parameter -- no type tag -- typechecker infers most general type
	\item in \typecase, matched value must be able to be instantiated differently for different uses.
	example:
	\begin{alltt}
	foo = \(\lambda\)df.
	  typecase df of
	    (f:\(\forall\)A.(A\(\rightarrow\)A)\(\rightarrow\)(A\(\rightarrow\)A)\(\pair{\mathtt{f add1}}{\mathtt{f not}}\)
	  else \(\ldots\)
	\end{alltt}
	\item languages with type inference always infer the most general type, but if there were explicit type tags in \Dynamic values, the programmer could have given a less general type so patterns should always match type tags that are more general than the pattern -- called tag instantiation
	\item first order pattern variables not expressive enough to match some examples so we add second order pattern variables like before that can be instantiated to type operators. Example where second order pattern variables are needed:
	\begin{alltt}
	applyTwice = \(\lambda\)df.\(\lambda\)dxy.
	  typecase df of
	    \{F,F'\} (f:F(P)->F'(P))
	      typecase dxy of
	        \{G,H\} (\(\pairtt{x}{y}\):F(G(Q)) \(\times\) F(H(Q)))
	          \(\pairtt{f x}{f y}\)
	      else ...
	   else ...
	\end{alltt}
	\item tag instantiation and second-order pattern variables cause some problems when used together. Second order pattern variables can depend on universal variables, but tag instantiation requires matching with more general types, so you dont know how many universal variables there will be. 
	Example:
	Tag \code{\forall A.(A\times A)\rightarrow A} matches pattern \code{\{F\}(f:\forall A.F(A)\rightarrow A)} with \code{F = \Lambda X.X\times X} but tag \code{\forall A,B.(A\times B)\rightarrow A} should also match the pattern because it is more general, but \texttt{F} does not depend on \texttt{B} (\code{F = \Lambda X.X \times ??}).
	\item Solution is to capture variables that appear in tag but not in a pattern in a tuple \code{P} and have all pattern variables depend on \code{P}. So pattern \code{\{F\}(f:\forall A.F(A)\rightarrow A)} is actually  \code{\{F\}(f:\forall A.F(A;P)\rightarrow A)}. \code{P} gets instantiated at run time. For the previously mentioned tag \code{\forall A,B.(A\times B)\rightarrow A}, \code{P} gets instantiated to \code{(B)}. Since arity of \code{P} is not known at compile type, a special tuple sort must be introduced. (Show type rules?)
	\item authors give typechecking and evaluation rules for implicit polymorphic language with \Dynamic but do not prove any theorems
	
	
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Leroy and Mauny (JFP 1993) Dynamics in ML
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Leroy and Mauny (JFP 1993) Dynamics in ML}
\begin{enumerate}
	\item Contribution is adding \Dynamic values to ML -- two extensions: closed type \Dynamic values (fully implemented in CAML) and non-closed type (prototyped in CAML.
	\item \dynamic construct takes one parameter -- type is inferred
	\item no explicit \typecase construct, instead \Dynamic elimination is integrated into ML pattern matching -- pattern written \code{dynamic(p:T)}, where \code{p} = pattern and \code{T} = type
\end{enumerate}

\subsubsection*{Closed-type \Dynamic values in ML}
\begin{enumerate}
	\item only allowed to create \Dynamic values with closed types
	\item so \code{dynamic(fn\;x \rightarrow x)} is legal because the inferred type is \code{\forall\alpha. \alpha\rightarrow\alpha} but \Dynamic in \code{fn\;x \rightarrow dynamic\;x} is illegal because \code{x} has type \code{\alpha} which is free -- type of value put into \Dynamic cannot be determined at compile time (would require run time type information to be passed to all functions, even those that dont create \Dynamic values because you dont know if nested functions do)
	\item allowing \Dynamic objects to have unclosed types would also break ML parametricity properties -- polymorphic fns need to operate uniformly over all input types -- ie \code{map\;g\;(f\;l) = f\;(map\;g\;l)} for \code{f:\forall\alpha.\alpha\;list\rightarrow\alpha\;list} but the following example does not have this property:
	\begin{alltt}
	let f = fn l ->
	  match (dynamic l) with
	    dynamic(m:int list) -> reverse l
	  | d -> l
	\end{alltt}
	\item type tag in \Dynamic value can match less general pattern -- so polymorphic pattern actually matches less things than specific pattern -- more general patterns need to appear first in case statements

	\item typing rules: \\
	type scheme $\sigma ::= \forall\alpha_1\ldots\alpha_n.\tau$\\
	type env $E : Var \rightarrow \sigma$\\
	$E\vdash a:\tau \Rightarrow b$ = ``expression $a$ has type $\tau$ in type env $E$'', $b$ is type-annotated version of $a$
	$Clos(\tau,V)$ = closure of type $\tau$ wrt type vars not in $V$ = $\forall\alpha_1\ldots\alpha_n.\tau$, where $\{\alpha_1,\ldots,\alpha_n\} = FV(\tau)\backslash V$\\
	$Clos(\tau,\emptyset)$ = type scheme obtained by generalizing free vars in $FV(\tau)$ \\
	$\vdash p:\tau\Rightarrow E$ = ``pattern $p$ has type $\tau$ and enriches type environment by $E$ \\
	$Clos(E,\emptyset)$ = type env obtained by creating type schemes from $\tau \in Rng(E)$\\
	\inferrule{E\vdash a:\tau\Rightarrow b \\ FV(\tau)\cap FV(E) = \emptyset}
	          {E\vdash \dynamic\;a:\Dynamic\Rightarrow\dynamic(b,Clos(\tau,\emptyset))} \\
	\inferrule{\vdash p:\tau\Rightarrow E}
	          {\vdash\dynamic(p:\tau):\Dynamic\Rightarrow Clos(E,\emptyset)}
	
	\item evaluation rules:\\
	\newcommand{\eval}{ \ensuremath{\rightarrow^*} }
	$\vdash v < p \eval m$ = ``matching of value v against pattern p results in m'' \\
	$\tau \leq \sigma$ = type $\tau$ is instance of type scheme $\sigma$ ($\sigma$ is more general) \\
	\inferrule{e\vdash b \eval v}
	          {e\vdash \dynamic(b:\sigma)\eval \dynamic(v:\sigma)} \\
	\inferrule{\vdash v < p \eval e \\ \tau \leq \sigma}
	          {\vdash \dynamic(v:\sigma) < \dynamic(p:\tau)\eval e}
	
	\item Soundness: if $[]\vdash a_0:\tau_0 \Rightarrow b_0$ for some type $\tau$, then we cannot derive $[]\vdash b_0 \eval \mathtt{wrong}$
	\item authors also show how to modify unification algorithm and discuss other implementation issues
\end{enumerate}




\subsubsection*{Non-closed-type \Dynamic values in ML}
\begin{enumerate}
	\item	closed-type \Dynamic values are not enough to match certain cases -- \texttt{print} fn might want to match \Dynamic that contains any pair, but a pattern like \code{dynamic((x,y):\alpha\times\beta)} only matches \Dynamic values whose internal type tag is at least as general as $\forall\alpha\forall\beta.\alpha\times\beta$ and will not match \Dynamic values where internal type is a pair of specific types.
	\item need existentially quantified pattern variables -- can have patterns like:\\
	\code{\exists\alpha.\exists\beta.dynamic((x,y):\alpha\times\beta)} -- matches \Dynamic that contains any pair \\
	\code{\exists\alpha.dynamic(x::l:\alpha\;list)} -- matches \Dynamic that contains any list \\
	\code{\exists\alpha.\exists\beta.dynamic(f:\alpha\rightarrow\beta)} -- matches \Dynamic that contains any fn \\

	\item existential and universal quantifiers can be mixed -- semantics depends on order of quantification\\
	\code{\forall\alpha.\exists\beta.dynamic(f:\alpha\rightarrow\beta)} -- matches \Dynamic that contains fn that operates uniformly on input -- $\beta$ depends on $\alpha$ -- example would be \code{f:\forall\alpha.\alpha\rightarrow\alpha\;list} \\
	\code{\exists\alpha.\forall\beta.dynamic(f:\alpha\rightarrow\beta)} -- matches \Dynamic that contains fn that returns $\beta$ for any $\beta$ -- no such fn!
	\item when type variable $\beta$ is allowed to depend on $\alpha$, like in example \code{\forall\alpha.\exists\beta.dynamic(f:\alpha\rightarrow\beta)}, typechecker must assume that $\beta$ ALWAYS depends on $\alpha$, so $\beta$ is actually type constructor parameterized by $\alpha$ -- otherwise this example will typecheck: \\
	\code{fn\;\forall\alpha.\exists\beta.dynamic(f:\alpha\rightarrow\beta)\rightarrow\;f(1)=f(true)} \\
	even though applying the fn to \code{dynamic(fn\;x\rightarrow x)} produces a run time type error -- \\
	With restriction, above example has type $\forall\alpha.\alpha\rightarrow S_\beta(\alpha)$ so you cannot apply the fn to both 1 and \texttt{true} because you will get types \code{S_\beta(int)} and \code{S_\beta(bool)} as operands to =
	
	\item typing rules: \\
	type scheme $\sigma ::= \forall\alpha_1\ldots\alpha_n.\tau$\\
	type env $E : Var \rightarrow \sigma$\\
	$E\vdash a:\tau \Rightarrow b$ = ``expression $a$ has type $\tau$ in type env $E$'', $b$ is type-annotated version of $a$
	$Clos(\tau,V)$ = closure of type $\tau$ wrt type vars not in $V$ = $\forall\alpha_1\ldots\alpha_n.\tau$, where $\{\alpha_1,\ldots,\alpha_n\} = FV(\tau)\backslash V$\\
	$Clos(\tau,\emptyset)$ = type scheme obtained by generalizing free vars in $FV(\tau)$ \\
	quantifier prefixes: $Q ::= \epsilon \mid \forall\alpha.Q \mid \exists\alpha.Q$  (assume vars renamed so same var is not bound twice) \\
	$BV(Q)$ = set of variables found by prefix $Q$ \\
	$\bar{\tau}$ = types that do not contain previously mentioned type constructors \\
	$\theta$ : TypeVar $\rightarrow \tau$  = type substitution \\
	$S:\textrm{TypeVar}\ldots \times Q \rightarrow \theta$ is defined as follows:\\
	\begin{align*}
	S(\alpha_1\ldots\alpha_n,\epsilon)         &= id \\
	S(\alpha_1\ldots\alpha_n,\forall\alpha.Q)  &= S(\alpha_1\ldots\alpha_n\alpha,Q) \\
	S(\alpha_1\ldots\alpha_n,\exists\alpha.Q) &= \{\alpha\mapsto S_\alpha(\alpha_1\ldots\alpha_n)\} \circ S(\alpha_1\ldots\alpha_n,Q) \\
	\end{align*}
	$\vdash p:\tau\Rightarrow E$ = ``pattern $p$ has type $\tau$ and enriches type environment by $E$ \\
	$Clos(E,\emptyset)$ = type env obtained by creating type schemes from $\tau \in Rng(E)$\\
	\inferrule{E\vdash a:\tau\Rightarrow b \\ FV(\tau)\cap FV(E) = \emptyset}
	          {E\vdash \dynamic\;a:\Dynamic\Rightarrow\dynamic(b,Clos(\tau,\emptyset))} \\
	\inferrule{FV(\bar{\tau})\subseteq BV(Q) \\ Q \vdash p:\bar{\tau}\Rightarrow E \\ \theta = S(\epsilon,Q)}
	          {Q\vdash\dynamic(p:\bar{\tau}):\Dynamic\Rightarrow Clos(\theta(E),\emptyset)}
	
	\item evaluation rules:\\
	\newcommand{\eval}{ \ensuremath{\rightarrow^*} }
	$\vdash v < p \eval m$ = ``matching of value v against pattern p results in m'' \\
	$T:\tau\times\textrm{Env}\rightarrow\bar{\tau}$ -- instantiates type constructors in $\tau$ -- defined as:
	\begin{align*}
	T(S_\alpha(\tau_1\ldots\tau_n),e) &= \bar{\tau}[\alpha_1\leftarrow T(\tau_1,e),\ldots,\alpha_n\leftarrow T(\tau_n,e)] \;\textrm{if}\; e(\alpha) = \lambda\alpha_1\ldots\alpha_n.\bar{\tau} \\
	T((\forall\alpha_1\ldots\alpha_n.\tau),e) &= \forall\alpha_1\ldots\alpha_n.T(\tau,e) \;\textrm{if}\; \{\alpha_1\ldots\alpha_n\}\cap Dom(e) = \emptyset
	\end{align*}
	$e$ -- evaluation environment (can also map type vars to type constructors) \\
	$\Gamma$ -- set of type equations to be solved \\
	\inferrule{e\vdash b \eval v}
	          {e\vdash \dynamic(b:\sigma)\eval \dynamic(v:T(\sigma,e))} \\
	\inferrule{   Q\vdash v < p \eval (e,\Gamma) 
	           \\ \bar{\sigma} = \forall\alpha_1\ldots\alpha_n.\bar{\tau}' 
	           \\ \{\alpha_1\ldots\alpha_n\}\cap BV(Q)=\emptyset}
	          {Q \vdash \dynamic(v:\bar{\sigma}) < \dynamic(p:\bar{\tau})\eval (e,\Gamma\cup\{\bar{\tau}'=\bar{\tau}\})}
	
	\item no soundness theorem for second extension
	
	\item authors also show how to modify unification algorithm and discuss other implementation issues
	
	 \end{enumerate}

\subsection*{Abadi, et al. vs Leroy and Mauny's \Dynamic language with implicit polymorphism}

\begin{tabular}{c|c}
Abadi, et al.                                    & Leroy and Mauny \\
\hline\hline
explicit \typecase construct                     & integrate into ML pattern matching \\
\hline
higher order pattern variables                   & existential pattern variables \\
\hline
\code{\forall\alpha.\alpha\rightarrow F[\alpha]} & $\forall\alpha.\exists\beta.\alpha\rightarrow\beta$ \\
\hline
arbitrary dependencies between pattern variables & mixed quantification only allows \\
(more expressive)                                & linear dependencies between pattern variables \\
\hline
ad-hoc restrictions on pattern variables         & simple interpretation in first order logic \\                                                 

\end{tabular}

\subsection*{Gray,Findler,Flatt - Fine-Grained Interoperability Through Mirrors and Contracts}


\bibliographystyle{acm}
\bibliography{dynamic}


\end{document} % THE INPUT FILE ENDS LIKE THIS