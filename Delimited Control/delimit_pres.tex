% delimit_pres.tex

\documentclass[letterpaper]{llncs}
%\documentclass[12pt]{article}	% YOUR INPUT FILE MUST CONTAIN THESE
\usepackage{url}
\usepackage{graphicx}
%\oddsidemargin  -0.4in
%\evensidemargin 0.0in
%\textwidth      7in
%\headheight     -0.5in
%\topmargin      0.0in
%\textheight     9.0in
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{xspace}



\begin{document}							% TWO LINES PLUS THE \end COMMAND AT
															% THE END

\title{Delimited Control - Presentation Notes}
\author{Stephen Chang}
\institute{}
\date{4/13/2010}
\maketitle

\section*{History}

\begin{enumerate}
	\item LISP - catch and throw - not first class - can only throw once to each catch
	\item call/cc
	\item Landin's J
	\item Reynolds - escape
\end{enumerate}

\section*{Constraining Control}%~\cite{Friedman1985ConstrainingControl}

\begin{verbatim}
@inproceedings{Friedman1985ConstrainingControl,
  author    = {Daniel P. Friedman and Christopher T. Haynes},
  title     = {Constraining Control},
  booktitle = {POPL},
  year      = {1985},
  pages     = {245-254},
}
@article{Haynes1987EmbeddingContinuations,
  author    = {Christopher T. Haynes and Daniel P. Friedman},
  title     = {Embedding Continuations in Procedural Objects},
  journal   = {ACM Trans. Program. Lang. Syst.},
  volume    = {9},
  number    = {4},
  year      = {1987},
  pages     = {582-598},
}
\end{verbatim}

\subsection*{Abstract}
Continuations, when available as first-class objects, provide a general control abstraction in programming languages. They liberate the programmer from specific control structures, increasing programming language extensibility. Such continuations may be extended by embedding them in functional objects. This technique is first used to restore a fluid environment when a continuation object is invoked. We then consider techniques for constraining the power of continuations in the interest of security and efficiency. Domain mechanisms, which create dynamic barriers for enclosing control, are implemented using fluids. Domains are then used to implement an unwind-protect facility in the presence of first-class continuations. Finally, we demonstrate two mechanisms, wind-unwind and dynamic-wind, that generalize unwind-protect.

\subsection*{Extending call/cc}

\begin{enumerate}
	\item extend call/cc - instead of passing current continuation to call/cc argument, pass closure that contains continuation - closure can also do other stuff
\begin{verbatim}
(define (call/cc-extended f)
  (call/cc
    (lambda (k)
      (let ([cob (lambda (v)
                  extra operations
                  (k v))])
        (f cob))))))
\end{verbatim}
	\item an extended call/cc is needed when implementing a fluid environment in a language with first class continuations
	\item standard fluid env impl (== means syntactic extension):
\begin{verbatim}
(fluid <var>) == (fluid-env '<var>)

(let-fluid <var> <exp> <body>) ==

(let ([own-env fluid-env] ; save previous fluid env
      [v <exp>]
      [body-thunk (lambda () <body>)]) ; don't want to eval body until new env is set
  (set! fluid-env ; extend env
    (lambda (x)
      (if (eq? x '<var>) v (own-env x))))
  (begin0
    (body-thunk)
    (set! fluid-env own-env)))
\end{verbatim}
	\item implementation above does not work with first class continuations - when continuation is invoked, it should continue in the same fluid env as when continuation was first captured
	\item extended call/cc for correctly handling fluid envs:
\begin{verbatim}
(define (call/cc-fluid f)
  (call/cc
    (lambda (k)
      (f (let ([own-env fluid-env]) ; capture env at the time continuation is created
           (lambda (x)
             (set! fluid-env own-env)
             (k v)))))))
\end{verbatim}
Why dont we need to restore old fluid-env when call/cc is done? Because call/cc aborts current continuation.
\end{enumerate}

\subsection*{Extending call/cc}

\begin{enumerate}
	\item sometimes we want to constrain continuations - example - continuation that can only be invoked once
\begin{verbatim}
(define (call/cc-one-shot f)
  (call/cc
    (lambda (k)
      (f (let ([alive #t])
           (lambda (v)
             (if alive
                 (begin
                   (set! alive #f)
                   (k v)
                 (error ...))))))))
\end{verbatim}
Of course, this example is not completely robust in that descendants of the continuation can still be invoked even if alive is false. To address this, we need a more complicated scheme where each continuation needs to keep track of all child continuations and be able to set all their alive flags to false. See paper for more info. For now we assume that this is not an issue.
	\item another example of constrained continuation - may only want to allow continuation jump if we are in a certain context
	\item can implement using fluid envs:
\begin{verbatim}
(define (domain thunk)
  (let-fluid domain-ref (unique) (thunk)))
  
(define (call/cc-domain f)
  (call/cc-fluid
    (lambda (k)
      (f (let ([own-d (fluid domain-ref)]) ; save domain at cont creation
           (lambda (v)
             (if (eq? (fluid domain-ref own-d) ; check that we are in proper domain
                 (k v)
                 (error ...)))))))))
\end{verbatim}
\end{enumerate}


\section*{The Theory and Practice of First-Class Prompts}%~\cite{Felleisen1998Prompts}

\begin{verbatim}
@inproceedings{Felleisen1998Prompts,
  author    = {Matthias Felleisen},
  title     = {The Theory and Practice of First-Class Prompts},
  booktitle = {POPL},
  year      = {1988},
  pages     = {180-190},
}
\end{verbatim}

\subsection*{Abstract}
An analysis of the $\lambda_v$-C-calculus and its problematic relationship to operational equivalence leads to a new control facility: the prompt-application. With the introduction of prompt-applications, the control calculus becomes a traditional calculus all of whose equations imply operational equivalence. In addition, prompt-applications enhance the expressiveness and efficiency of the language. We illustrate the latter claim with examples from such distinct areas as systems programming and tree processing.






\section*{Control Delimiters and Their Hierarchies}%~\cite{Sitaram1990Hierarchies}

\begin{verbatim}
@article{Sitaram1990Hierarchies,
  author    = {Dorai Sitaram and Matthias Felleisen},
  title     = {Control Delimiters and Their Hierarchies},
  journal   = {Lisp and Symbolic Computation},
  volume    = {3},
  number    = {1},
  year      = {1990},
  pages     = {67-99},
}
\end{verbatim}

\subsection*{Abstract}
Since control operators for the \textit{unrestricted} transfer of control are too powerful in many situations, we propose the \textit{control delimiter} as a means for restricting control manipulations and study its use in Lisp- and Scheme-like languages. In a Common Lisp-like setting, the concept of delimiting control provides a well-suited terminology for explaining different control constructs. For higher-order languages like Scheme, the control delimiter is the means for embedding Lisp control constructs faithfully and for realizing high-level control abstractions elegantly. A deeper analysis of the examples suggests a need for an entire \textit{control hierarchy} of such delimiters. We show how to implement such a hierarchy on top of the simple version of a control delimiter.





\section*{Abstracting Control}%~\cite{Danvy1990AbstractingControl}

\begin{verbatim}
@inproceedings{Danvy1990AbstractingControl,
  author    = {Olivier Danvy and Andrzej Filinski},
  title     = {Abstracting Control},
  booktitle = {LISP and Functional Programming},
  year      = {1990},
  pages     = {151-160},
}
\end{verbatim}


\subsection*{Abstract}
The last few years have seen a renewed interest in continuations for expressing advanced control structures in programming languages, and new models such as Abstract Continuations have been proposed to capture these dimensions. This article investigates an alternative formulation, exploiting the latent expressive power of the standard continuation-passing style (CPS) instead of introducing yet other new concepts. We build on a single foundation: abstracting control as a \textit{hierarchy} of continuations, each one modeling a specific language feature as acting on nested \textit{evaluation contexts}. 

We show how \textit{iterating} the continuation-passing conversion allows us to specify a wide range of control behavior. For example, two conversions yield an abstraction of Prolog-style backtracking. A number of other constructs can likewise be expressed in this framework; each is defined independently of the others, but all are arranged in a hierarchy making any interactions between them explicit. 

This approach preserves all the traditional results about CPS, e.g., its evaluation order independence. Accordingly, our semantics is directly implementable in a call-by-value language such as Scheme or ML. Furthermore, because the control operators denote simple, typable lambda-terms in CPS, they themselves can be statically typed. Contrary to intuition, the iterated CPS transformation does not yield huge results: except where explicitly needed, all continuations beyond the first one disappear due to the extensionality principle ($\eta$-reduction). 

Besides presenting a new motivation for control operators, this paper also describes an improved conversion into applicative-order CPS. The conversion operates in one pass by performing all administrative reductions at translation time; interestingly, it can be expressed very concisely using the new control operators. The paper also presents some examples of nondeterministic programming in direct style.  







\bibliographystyle{acm}
\bibliography{delimit}


\end{document} % THE INPUT FILE ENDS LIKE THIS